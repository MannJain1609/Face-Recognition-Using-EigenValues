# -*- coding: utf-8 -*-
"""20110108_Assignment2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e6cWm4Q8aNo_bBoTNwwiaeFAzIs_b56z
"""

# Commented out IPython magic to ensure Python compatibility.
# Getting data from git repo
!git clone https://github.com/MannJain1609/Face-Recognition-Using-EigenValues
# %cd Face-Recognition-Using-EigenValues

import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
import PIL
import os
import math

Faces_Dataset = "/content/Face-Recognition-Using-EigenValues/Faces _Dataset"
Images = []

for file in os.listdir(Faces_Dataset):
  if(file=='README'):
    continue
  ind_path = f"{Faces_Dataset}/{file}"
  for image in os.listdir(ind_path):
    Images.append(ind_path + "/" + image)
    filename, extension  = os.path.splitext(f"{ind_path}/{image}")
    if extension == ".pgm":
      new_file = "{}.png".format(filename)
      with PIL.Image.open(f"{ind_path}/{image}") as im:
        im.save(new_file)
      os.remove(f"{ind_path}/{image}")

num_faces = 40        # Number of distinct faces
image_per_face = 10        # Images per face
W = 92
H = 112         # Width and Height of images
total_images = num_faces * image_per_face;

face_mat = np.zeros((total_images,W*H),dtype=np.float64)   # To store images

# Getting all images into the face matrix
count = 0;
fig = plt.figure(figsize=(150,300))
for image in Images:
  img = plt.imread(image)
  face_mat[count,:] = np.array(img, dtype='float64').flatten()
  if(count<100):
    fig.add_subplot(20,5,count+1)
    plt.imshow(img,cmap = 'gray')
  count += 1;
plt.show()

#map to store the ids corresponding to images
train_map = {}
test_map = {}

def train_test_split(face_mat,Train_per_face = 8):
    # Train test Split:
    Train_images = Train_per_face * num_faces          # Total Train Images
    Test_per_face = image_per_face - Train_per_face      # Test Images per face
    Test_images = Test_per_face*num_faces             # Total Test Ims
   
    train_mat = np.zeros((Train_images,W*H))   # Train Matrix
    test_mat = np.zeros((Test_images,W*H))     # Test Matrix
    train_count = 0                         # Train counter
    test_count = 0                          # Test counter

    #to uniquely determine the person
    person_id = -1
    for count,face in enumerate(face_mat):
      if count%image_per_face == 0:
        person_id += 1;
      if count%image_per_face <Test_per_face:
        # print("TEST",count,test_count)
        test_mat[test_count] = face_mat[count]
        test_map[test_count] = person_id
        test_count += 1
      else:
        # print("TRAIN",count,train_count)
        train_mat[train_count] = face_mat[count]
        train_map[train_count] = person_id
        train_count += 1
    return train_mat,test_mat

def show_im(image):
  plt.imshow(image,cmap='gray')
  plt.show()

train_per_face = 8             # Train images per face
train_images = train_per_face * num_faces          # Total train images
face_mat /= 255                 # Making images out of 1

# Train Test split
train_mat, test_mat = train_test_split(face_mat,train_per_face)

# We need A of shape (W*H,Train_images)
#A = train_mat.T
A = train_mat.T
print("Shape of A is ",A.shape)

# Calculating Average Face
A_avg = np.mean(A,axis=1)
print("Shape of A_avg is ",A_avg.shape)
print("This is the average face-")
show_im(np.reshape(A_avg,(H,W)))

# Calculating Normalized Faces
Phi = np.subtract(A.T ,A_avg.T).T
print("Phi shape is ",Phi.shape)

# Calculating Train_images*Train_images covarience matrices and their eigen values
Cov = np.dot(Phi.T,Phi)
print("Cov_Train_images*Train_images shape is ",Cov.shape)

# Finding the Eigen vectors of the Covariance Matrix
eig,eig_vec = np.linalg.eig(Cov)
eig,eig_vec = np.real(eig),np.real(eig_vec)
print("These are the 20 most important eigen values - ")

plt.plot(eig[:20])
plt.show()

# Choosing number of principal components
variance = 0.99
for k in range(len(eig)):
  if np.sum(eig[:k])/np.sum(eig) > variance:
    print("We choose {} principal components to capture {} variance out of Train_images*Train_images covariance.".format(k,variance))
    break

print(type(eig_vec))

eig_pairs = [(eig[index], eig_vec[:,index]) for index in range(len(eig))]

# Sort the eigen pairs in descending order:
eig_pairs.sort(reverse=True)
eig_sort  = np.array([eig_pairs[index][0] for index in range(len(eig))])
eig_vec_sort = np.array([eig_pairs[index][1] for index in range(len(eig))])

# Selecting K values out of train_images and dotting W.H*train_images with train_images*k
eig_k,eig_k_vec = eig_sort[:k],np.dot(Phi,eig_vec_sort[:,:k])
print(eig_k.shape,eig_k_vec.shape)

print("These are the top 5 eigen faces")
for i in range(5):
  show_im(np.reshape(eig_k_vec.T[i],(H,W)))

# Projecting the Normalized images on to the K vector Space
#Train_images*W.H dot W.H*k
embedded = np.dot(Phi.T,eig_k_vec)
print("Embeddin for all faces", embedded.shape)

B = test_mat.T
print("Shape of B is ",B.shape)

# Calculating Normalized Faces
Phi_test = np.subtract(B.T ,A_avg.T).T
print("Phi test shape is ",Phi_test.shape)

show_im(np.reshape(Phi_test.T[0],(H,W)))

omega = np.dot(Phi_test.T,eig_k_vec)
print("Omega shape is ",omega.shape)

print(eig_k_vec.shape)
omega.shape, Phi_test.shape

#function to check faces with the train images
def check_faces(face,known_faces):
    check_mat = np.zeros(test_mat.shape[0])
    for i in range(test_mat.shape[0]):
      min_dist = float("inf")
      for j in range(train_mat.shape[0]):
        dist = np.linalg.norm(face[i]-known_faces[j])
        if(dist < min_dist):
          min_dist = dist
          check_mat[i] = train_map[j]
    return check_mat

#function to get the correct and incorrect count
def corrects_incorrects(check_mat):
  correct = 0
  incorrect = 0
  for i in range (len(check_mat)):
    if check_mat[i] == test_map[i] :
      correct += 1
    else:
      incorrect += 1
  return correct,incorrect

def accuracy(correct,incorrect):
  acc = correct/(correct+incorrect)
  return acc*100

check_matrix = check_faces(omega,embedded)
correct,incorrect = corrects_incorrects(check_matrix)
acc = accuracy(correct,incorrect)
print("correct count : ",correct)
print("incorrect_count: " ,incorrect)
print("Accuracy of the model is {} %".format(acc))

"""The accuracy above is for the test data splitted from the original data. The accuracy will be lower for a new image."""

for i in range(len(check_matrix)):
  if check_matrix[i] == test_map[i] : 
    print("The test image {} is matched with person id {}".format(str(i),str(test_map[i])))
  else:
    print("The test image {} is matched with person id {}, however real is with id {}, false detected".format(str(i),str(check_matrix[i]),str(test_map[i])))

